
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROGRAM, READ, PRINT, CONST;
terminal IF, ELSE, DO, WHILE, BREAK, CONTINUE, RETURN, NEW, VOID;
terminal EQUAL, NOTEQUAL, LESS_OR_EQUAL, GREATER_OR_EQUAL, LESS, GREATER, AND, OR, ASSIGN, INC, DEC, PLUS, MINUS, MUL, DIV, MOD;
terminal COLON, SEMI, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, BOOL_CONST, CHAR_CONST; 

terminal Integer NUM_CONST;
terminal String IDENT;

nonterminal ProgramDeclList;
nonterminal DeclList, Decl, VarDeclaration, MultipleVarDeclarations, VarDecl, ConstDeclaration, MultipleConstDeclarations, ConstDecl, Const, VarDeclList; 
nonterminal Type, MethodDeclList, MethodDecl, ReturnType, FormPars, FormalParamList, FormalParamDecl;
nonterminal StatementList, Statement, DesignatorStatement;
nonterminal Condition, CondTerm, CondFact;
nonterminal Matched, Unmatched;
nonterminal Designator, Expr, Term, Factor, MulFacList, ActualPars, ActualParamList;
nonterminal Assignop, Relop, Addop, Mulop;
nonterminal Parameters, OptArgsOnly, OptArgs, OptArg;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program;

/* Program */

Program ::=	(Program) PROGRAM ProgName:p ProgramDeclList LBRACE MethodDeclList RBRACE;

ProgName ::=	(ProgName) IDENT:programName;

ProgramDeclList ::= (ProgramDecls) DeclList
					|
					(NoProgramDecl) /* epsilon */
					;

/* Variable Declarations */

DeclList ::=	(MultipleDeclarations) DeclList Decl
				|
				(SingleDecl) Decl
				;
				
Decl ::=	(ConstDeclarations) CONST Type:constType ConstDeclaration
			|
			(VarDeclarations) Type:varType VarDeclaration
			;
			
VarDeclList ::=	(VarDeclarationsList) VarDeclList Type:varType VarDeclaration
				|
				/* epsilon */
				;			
			
VarDeclaration ::=	(MultipleVarDecls) MultipleVarDeclarations VarDecl SEMI
					|
					(SingleVarDecl) VarDecl SEMI
					|
					(VarDeclSemiError) error SEMI:l
					{: parser.report_error("Izvrsen oporavak do ; na liniji " + lleft, null); :}
					;
					
MultipleVarDeclarations ::=	(MultipleCommaSeparatedVarDecls) MultipleVarDeclarations VarDecl COMMA
							|
							(FirstVarDecl) VarDecl COMMA
							|
							(VarDeclCommaError) error COMMA:l
							{: parser.report_error("Izvrsen oporavak do , na liniji " + lleft, null); :}
							;
							
VarDecl ::=	(VarDecl) IDENT:varName;

ConstDeclaration ::=	(MultipleConstDecls) MultipleConstDeclarations ConstDecl SEMI
						|
						(SingleConstDecl) ConstDecl SEMI
						|
						(ConstDeclSemiError) error SEMI:l
						{: parser.report_error("Izvrsen oporavak do ; na liniji " + lleft, null); :} 
						;
					
MultipleConstDeclarations ::=	(MultipleCommaSeparatedConstDecls) MultipleConstDeclarations ConstDecl COMMA
								|
								(FirstConstDecl) ConstDecl COMMA
								|
								(ConstDeclCommaError) error COMMA:l
								{: parser.report_error("Izvrsen oporavak do , na liniji " + lleft, null); :}
								;

ConstDecl ::= 	(ConstDecl) IDENT:constName ASSIGN Const:constValue;	

Const ::=	(BoolConst) BOOL_CONST:bool
			|
			(CharConst) CHAR_CONST
			|
			(NumConst) NUM_CONST
			;			

Type ::=	(Type) IDENT:typeName;


/* Method Declarations */

MethodDeclList ::=	(MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl) /* epsilon */
					;
					
MethodDecl ::=	(MethodDecl) ReturnType:retType IDENT:methodName LPAREN Parameters RPAREN VarDeclList LBRACE StatementList RBRACE;

ReturnType ::=	(RetType) Type
				|
				(RetVoid) VOID
				;

FormPars ::=	(FormParams) FormalParamList
				|
				(NoFormParam) /* epsilon */
				;		
				
FormalParamList ::=	(FormalParamDeclarations) FormalParamList COMMA FormalParamDecl
					|
					(SingleFormalParamDecl) FormalParamDecl 
					;	
					
FormalParamDecl ::=	(FormalParamDeclaration) Type:paramType IDENT:paramName
					|
					(FormalParamDeclError) error:l
					{: parser.report_error("Izvrsen oporavak na liniji " + lleft, null); :} 
					;

Parameters ::=	(FormParametersOnly) FormPars
				|
				(OptionalArgumentsOnly) OptArgsOnly
				;			
						

OptArgsOnly ::=	(OptArgumentsOnly) OptArgsOnly COMMA OptArg
				|
				(SingleOptArg) OptArg
				;
				
OptArgs ::=	(OptArguments) OptArgs COMMA OptArg
			|
			(NoOptArgs) /* epsilon */
			;				

OptArg ::=	(OptArg) Type:paramType IDENT:paramName ASSIGN Const; 

/* Statements */

StatementList ::=	(Statements) StatementList Statement
					|
					(NoStmt) /* epsilon */
					;
					
Statement ::= 	(MatchedStmt) Matched
				|
				(UnmatchedStmt) Unmatched
				;
				
Unmatched ::=	(UnmatchedIf) IF LPAREN Condition RPAREN Statement
				|
				(UnmatchedIfElse) IF LPAREN Matched RPAREN ELSE Unmatched
				;									

Matched ::=		(DesignatorStmt) DesignatorStatement SEMI
				|	
				(DesignatorStmtError) error SEMI:l
				{: parser.report_error("Izvrsen oporavak do ; na liniji " + lleft, null);  :}
				|
				(ReadStatement) READ LPAREN Designator RPAREN SEMI
				|
				(PrintStatement) PRINT LPAREN Expr RPAREN SEMI
				|
				(PrintStatementNumConst) PRINT LPAREN Expr COMMA NUM_CONST RPAREN SEMI 
				|
				(BreakStatement) BREAK SEMI
				|
				(ContinueStatement) CONTINUE SEMI
				|
				(ReturnStatement) RETURN SEMI
				|
				(ReturnExprStatement) RETURN Expr SEMI
				|
				(MatchedStatement) IF LPAREN Condition RPAREN Matched ELSE Matched
				|
				(DoWhileStatement) DO Matched WHILE LPAREN Condition RPAREN SEMI
				|
				(Stmt) LBRACE StatementList RBRACE
				;
				
DesignatorStatement ::=	(DesignatorAssignStatement) Designator Assignop Expr
						|
						(DesignatorIncStatement) Designator INC
						|
						(DesignatorDecStatement) Designator DEC
						|
						(DesignatorFunctionCall) Designator LPAREN ActualPars RPAREN
						;
							

Designator ::=	(DesignatorIdent) IDENT 
				|
				(DesignatorIdentArray) IDENT LBRACKET Expr RBRACKET
				;		
				
Expr ::=	(AddOpTermExpr) Expr Addop Term
			|
			(NegTermExpr) MINUS Term
			|
			(PosTermExpr) Term
			;
			
Term ::=	(Term) Factor MulFacList;

MulFacList ::= 	(MulOpFactor) MulFacList Mulop Factor 
				|
				(NoMulopFactor) /* epsilon */
				;
						
			
Factor ::= 	(ConstFactor) Const
			|
			(ExprFactor) LPAREN Expr RPAREN
			|
			(NewArray) NEW Type:arrayType LBRACKET Expr RBRACKET
			|
			(Var) Designator
			|
			(FunctionCall) Designator LPAREN ActualPars RPAREN
			|
			(NewObj) NEW Type:objType
			;	
			
ActualPars ::=	(ActualPararameters) ActualParamList
				|
				(NoActualPars) /* epsilon */
				;					
				
ActualParamList ::=	(ActualParams) ActualParamList COMMA Expr
					|
					(ActualParam) Expr
					;
					
/* Conditions */

Condition ::=	(MultipleCondTerms) Condition OR CondTerm
				|
				(SingleCondTerm) CondTerm
				|
				(ErrorCond) error:l
				{: parser.report_error("Izvrsen oporavak do ) na liniji " + lleft, null); :}
				;


CondTerm ::=	(MultipleCondFacts) CondTerm AND CondFact
				|
				(SingleCondFact) CondFact
				; 

CondFact ::=	(CondFactExpr) Expr
				|
				(CondFactRelOpExpr) Expr Relop Expr
				; 												


/* Operators */

Assignop ::=	(Assignop) ASSIGN;											

Relop ::=	(RelopEqual) EQUAL
			|
			(RelopNotEqual) NOTEQUAL
			|
			(RelopLessOrEqual) LESS_OR_EQUAL
			|
			(RelopGreaterOrEqual) GREATER_OR_EQUAL
			|
			(RelopLess) LESS
			|
			(RelopGreater) GREATER
			;

Addop ::= 	(AddopPlus) PLUS
	  		|
	  		(AddopMinus) MINUS
	  		;
	  
Mulop ::= 	(MulopMul) MUL
 	   	   	|
 	   		(MulopDiv) DIV
 	   		|
 	   		(MulopMod) MOD
 	   		;
 	   		